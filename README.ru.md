# Каналы (channels)
Каналы (channels, pipes) - это удобная абстракция для построения приложений работающих в
многопоточной среде. Они используются для передачи сообщений между потоками и,одновременно с этим, как средство синхронизации потоков. Я буду ссылаться на "Go-style channels" потому, что на мой взгляд, важная способность каналов в языке GO - это мультиплексирование каналов.

Реализации каналов на языке C++ конечно же есть, например в библиотеки boost::fibers, можно найти реализацию двух [видов каналов](https://www.boost.org/doc/libs/1_84_0/libs/fiber/doc/html/fiber/synchronization/channels.html). Так же там можно найти [описания способов](https://www.boost.org/doc/libs/1_84_0/libs/fiber/doc/html/fiber/when_any.html) мультиплексирования, правда не каналов, но и к ним можно применить подобную технику.

Реализация из boost не предлагает мультиплексирование каналов из коробки и никак не позиционирует себя на роль "Go-style channels", оно и понятно, представлен простой механизм передачи сообщений из одного ``fiber`` в другой. Предложенная техника мультиплексирования, которую можно применить и к каналам, это простая реализация "в лоб". Она состоит из запуска дополнительных промежуточных fibers по одному на задачу (или в нашем случае на канал). Это довольно затратно.

[Ещё одна реализация](https://github.com/Balnian/ChannelsCPP), у меня это была первая строчка поиска в google "go-style channels c++". Использует перегруженный оператор ``<<`` и ``>>``, есть мультиплексирование, но реализована через случайные опрос каналов в бесконечном цикле. А класс ``go::internal::ChannelBuffer`` содержит ошибку использования ``std::conditional_variable`` и поля ``std::atomic_bool is_closed;`` (обсудим это ниже).

Обе реализации использую циклический буфер для хранения передаваемых сообщений. Я бы хотел показать, что абстракция каналов - это нечто большее, чем просто циклический буфер с примитивами синхронизации. Попробую сформулировать требования для идеальной реализации каналов:
1) Мультиплексирование должно быть реализовано без использования "тяжёлых" сущностей.
    Под тяжелыми сущностями я подразумеваю следующее:
    * запуск дополнительных потоков, корутин (любых). 
    * не должно быть никаких "фоновых" или "сервисных" потоков.
    * выделение динамической памяти под каки-либо дополнительные структуры.

    Все что должно быть создано для реализации мультиплексирования, создается только в месте использования.
2) Блокировка потока в случае отсутствии данных в канале использует стандартные средства ОС (нет бесконечного цикла под капотом).
3) Блокировка должны быть до тех пор, пока данные не появяться в любом канале (простой round-robin не подойдёт).
4) Не вызывать блокировку, если в канале есть доступные данные.
   Должны быть возможность реализовать некоторые каналы, из которых можно прочитать данные без вызова блокировок ОС, или могут быть реализованы "поверх" lockfree структур данных. ([Polling](https://en.wikipedia.org/wiki/Polling_(computer_science)))
5) Поддержка интерфейса итераторов для чтения из канала:
   ```c++
    Channel<int>& ch = /*...*/;
    for(const auto& value: ch) {
        /*...*/
    }
   ```
6) Интерфейс канала допускает любую реализацию получения данных. В качестве простого примера представим себе канал, данные для которого генерируются "на лету":
   ```c++
    template<class T, class Fn>
    class ChannelGenerator: public Channel<T>
    {
        Fn generator;
        /*...*/
    };
    /*...*/
    auto channel = create_generator<int>(
        [counter = 0] { return counter++; }
    );
    for(const auto& value: channel) { // infinity loop
        std::cout << "value from channel: " << value << std::endl;
    }
    // print:
    // value from channel: 0
    // value from channel: 1
    // value from channel: 2
    // ....
   ```

Добавлю и одно ограничение, по-умолчанию все каналы SPSC (single producer single consumer). Это ограничение сильно упрощает базовую реализацию, но ничего не мешает и сделать отдельные MPMC каналы.

## Простая реализация канала
Самая простая реализация MPMC канала с фиксированным буфером можно представить так:
```c++
template<class T, std::size_t N>
class Channel {
    CyclicBuffer<T, N> buffer;
    bool closed = false;

    mutable std::mutex              mt;
    mutable std::condition_variable cv;
public:
    using value_type = T;
};
```
Пример реализации метода recv:
```c++
bool recv(T& value)
{
    std::unique_lock lock{mt};
    cv.wait(lock, [this]{ return closed || !buffer.empty(); });
    if (closed) {
        return false;
    }
    value = buffer.pop();
    lock.unlock();
    cv.notify_all();
    return true;
}
```
Метод send реализуется схожим образом.
Теперь подумаем как можно добавить возможность мультиплексирования. Мы пока проигнорируем требования не вызывать блокировку, если в канале есть данные.
В данной реализация для синхронизации между потоками и ожидания читателя новых данных (если их ещё нет в буфере) использует пару из ``std::mutex`` и ``std::condition_variable``.
Для реализации мультиплексирования должен быть класс объединяющий наши каналы.
```c++
template<class ...Channels>
class ChannelSelect {
    Channels& ...channels;
public:
    ...
};
```
Теперь мы должны подумать какой интерфейс должен быть у нашего класса ``ChannelSelect``.
Напомню, что каналы могут передавать разные типы данных, поэтому простой интерфейс функии ``recv`` нам не подходит.
Оказывается объединять каналы можно по разному:

#### Способ 1
Можно вызвать ``callback`` для каждого канала, как в языке GO или библиотке [ChannelsCPP](https://github.com/Balnian/ChannelsCPP), вот пример использования:
```c++
void fibonacci(Chan<int>& c, Chan<int>& quit)
{
    int x=0, y = 1;
    for (bool go = true; go;)
    {
        Select
        {
            Case{
                c << x,
                [&] {
                    int t = x;
                    x = y;
                    y += t;
                }
            },
            Case{
                quit,
                [&](auto v) {
                    cout << "quit" << endl;
                    go = false;
                }
            }
        };
    }
}
```
Тут ``Select`` и ``Case`` - это шаблонные классы из библиотеки.

#### Способ 2
Метод ``recv`` возвращает комбинацию типов. И тут возможны два подварианта:
  1) Ожидать готовность всех объединённых каналов и возвращать ``std::tuple``.
     ```c++
     bool recv(std::tuple<typename Channels::value_type...>& value);
     ```
     Объединенный канал быдет считаться закрытым, если хотябы один из его подканалов закрыт.
  2) Ожидать готовность любого из объединенного канала и возвращать ``std::variant``
     ```c++
     bool recv(std::variant<typename Channels::value_type...>& value);
     ```
     Объединенный канал быдет считаться закрытым, если все из его подканалов закрыты.

Вариант 2 более гибкий ведь на его основе можно реализовать GO-style классы ``Select`` и ``Case``.

Простоя идея реализации мультиплексирования:
1) Нужно как-то сообщить каналу, что "над ним" кто-то есть. Раз мы не можем вызвать метод ``recv`` (мы заблокируемся), мы добавим в канал дополнительное поле - указатель (например на функцию), чтобы "писатель" после добавления данных разбудил "читателя".
2) В классе ``ChannelSelect`` есть свои пара ``std::mutex`` + ``std::condition_variable``.
3) Перед блокировкой класс ``ChannelSelect`` должен опросить все каналы на наличие в них данных. Таким образом в класс ``Channel`` нужно добавить метод ``poll``:
   ```c++
    bool poll() const
    {
        std::unique_lock lock{mt};
        return !buffer.empty();
    }
   ```
## Минус такого подхода
Такая архитектура позволяет удовлетворить все требования из списка кроме требования №4.
   
Часто я вижу ошибку при использования связки ``std::mutex`` + ``std::condition_variable`` - заменить некоторые (или все!) поля класса на атомарные переменные и изменять их без блокировки мьютекса. Действительно, метод [notify](https://en.cppreference.com/w/cpp/thread/condition_variable/notify_all) у класса ``std::condition_variable`` можно вызвать без блокировки. Но это не значит, что можно использовать ``std::condition_variable`` только для пробуждения другого потока!
Проилюстрирую проблему:
1) "Писатель" поместил данные (одно сообщение) в пустой циклический буфер (пусть он будет полностью lock-free) без блокировки мьютекса.
2) "Писатель" вызвал ``cv.notify_one()``. Больше данных "писатель" не предоставит в течении долгого времени (или никогда).
3) "Читатель" блокирует мьютекс и проверяет наличие данных в циклическом буфере, ничего не находит.
4) "Читатель" засыпает на ``cv.wait(...)``.

Представим, что хронологически порядок был таким: 3, 1, 2, 4. Таким образом, "читатель" заснет даже если есть данные в буфере, и разбудить его сможет только "писатель", когда он добавит следующую порцию данных. Но "писатель" мог закончить свою работу предоставив в буфер последние данные, тогда "читатель" заснет на всегда (deadlock).

Пример ошибки можно увидеть в [тут](https://github.com/Balnian/ChannelsCPP/blob/1ba5fd6b56d2983387356294e785b197c9b8e132/ChannelsCPP/ChannelBuffer.h#L84).

## Реализация на основе semaphore
Семафор лучше подходит для реализации канала. Свойства семафора позволяю реализовать lock-free канал. Если в канале есть данные, то блокироваться необязательно. Однако нам все равно нужно использовать его каждый раз во время чтения и записи в канал. Требования не блокироваться при наличии данных в канале перетекает в реализацию семафора. Обычно, реализация семафора - это тонкая обертка над семафором ОС, а он в свою очередь представляте собой некий дескриптор ОС. Это то, что мы обычно ожидаем, а значит, прямое использование семафора нам не подходит.

# Объект события
Все, что нам нужно, это уведомить другой поток, что новые данные появились (или появилось место в буфере для записи). Для этого лучше всего подходит концепция событий. Объект событи обычно работает через механизм подписки на событие.
У нас есть ограничение SPSC (single producer single consumer), а значит у события может быть только один подписчик. А раз так, то мы можем представить объект события простым классом:
```c++
class Event
{
    std::atomic<std::uintptr_t> signal {0};
public:
    void emit() noexcept;
    bool poll() const noexcept;
    void subscribe(IHandler* handler) noexcept;
    void reset() noexcept;
};
```
Класс имеет одно единственно поле signal, которе хранит указатель на объект подписчика. Вот его интерфейс:
```c++
class IHandler
{
public:
    virtual void notify() noexcept = 0;
    virtual ~IHandler() noexcept {};
    virtual void wait() noexcept = 0;
};
```
``std::uintptr_t`` тут не просто так, дело в том, что наше событие может быть в 2 состояних: событие находится в сигнальном состоянии и нет. Для хранения этого сигнального состояния в отдельном атомарном поле я посчитал слишком расточительным, для этого достаточно одного бита, поэтому объединил его с указателем, все равно старшие биты указателей не используются.

Номер бита описан следующим образом:
```c++
// самый старший бит std::uintptr_t
constexpr std::uintptr_t bit = (std::uintptr_t(1) << (sizeof(std::uintptr_t) * CHAR_BIT - 1));
```

Что делают методы класса ``Event``:
* ``poll`` опрос события, true - если событие произошло:
    ```c++
    bool Event::poll() const noexcept
    {
        return signal.load(std::memory_order_relaxed) & bit;
    }
    ```
* ``emit`` устанавливает событие в сигнальное состояние
    ```c++
    void Event::emit() noexcept
    {
        if (!poll()) {
            if(auto handler = signal.fetch_or(bit)) {
                reinterpret_cast<IHandler*>(handler)->notify();
            }
        }
    }
    ```
  Тут мы проверяем, что событие ещё не произошло, если это так, то читаем указатель с одновремнной установкой самого старшего бита, и вызываем у него ``notify()``.
* ``subscribe`` подписаться на событие, передача `` nullptr`` отписывает от события:
    ```c++
    void Event::subscribe(IHandler* handler) noexcept
    {
        signal.exchange(reinterpret_cast<std::intptr_t>(handler));
    }
    ```
* ``reset`` сбрасывает событие в несигнальное состояние:
    ```c++
    void Event::reset() noexcept
    {
        signal.fetch_and(~bit);
    }
    ```
Все методы атомарные, разве что метод ``emit`` вызовет метод ``notify``, который в свою очередь, задействует семафор.
Важное свойство объекта события - это то, что повторные вызовы ``emit`` будут только читать атомарную переменную и ничего больше не делать, пока событие вновь не будет сброшено.

Класс ``Handler`` - это простая реализация на основе семафора:
```c++
class Handler: public IHandler
{
    Semaphore semaphore;
public:
    void notify() noexcept override
    {
        semaphore.release();
    }
    void wait() noexcept override
    {
        semaphore.acquire();
    }
};
```
